using System;
using System.Diagnostics;
using System.Diagnostics.Tracing;
using System.Text;
using Microsoft.Diagnostics.Tracing;
using Address = System.UInt64;
using Diagnostics.Tracing.Parsers;
using Diagnostics.Tracing;

#pragma warning disable 1591        // disable warnings on XML comments not being present

// This code was automatically generated by the TraceParserGen tool, which converts
// an ETW event manifest into strongly typed C# classes.
namespace Microsoft.Diagnostics.Tracing.Parsers
{
    using Microsoft.Diagnostics.Tracing.Parsers.Process;

    public sealed class ProcessTraceEventParser : TraceEventParser
    {
        public static string ProviderName = "Microsoft-Windows-Kernel-Process";
        // GUID 22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716
        public static Guid ProviderGuid = new Guid(unchecked((int)0x22fb2cd6), unchecked((short)0x0e7b), unchecked((short)0x422b), 0xa0, 0xc7, 0x2f, 0xad, 0x1f, 0xd0, 0xe7, 0x16);
        public enum Keywords : long
        {
            WINEVENT_KEYWORD_PROCESS = 0x10,
            WINEVENT_KEYWORD_THREAD = 0x20,
            WINEVENT_KEYWORD_IMAGE = 0x40,
            WINEVENT_KEYWORD_CPU_PRIORITY = 0x80,
            WINEVENT_KEYWORD_OTHER_PRIORITY = 0x100,
        };

        public ProcessTraceEventParser(TraceEventSource source) : base(source) { }

        public event Action<ProcessStartTraceData> ProcessStart
        {
            add
            {
                // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
                source.RegisterEventTemplate(new ProcessStartTraceData(value, 1, 1, "ProcessStart", new Guid(), 1, "Start", ProviderGuid, ProviderName));
            }
            remove
            {
            }
        }
        public event Action<ProcessStopTraceData> ProcessStop
        {
            add
            {
                // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName
                source.RegisterEventTemplate(new ProcessStopTraceData(value, 2, 2, "ProcessStop", new Guid(), 2, "Stop", ProviderGuid, ProviderName));
            }
            remove
            {
            }
        }

        #region Event ID Definitions
        public const TraceEventID ProcessStartEventID = (TraceEventID)1;
        public const TraceEventID ProcessStopEventID = (TraceEventID)2;
        public const TraceEventID ThreadStartEventID = (TraceEventID)3;
        public const TraceEventID ThreadStopEventID = (TraceEventID)4;
        public const TraceEventID ImageLoadEventID = (TraceEventID)5;
        public const TraceEventID ImageUnloadEventID = (TraceEventID)6;
        public const TraceEventID CpuBasePriorityChangeEventID = (TraceEventID)7;
        public const TraceEventID CpuPriorityChangeEventID = (TraceEventID)8;
        public const TraceEventID PagePriorityChangeEventID = (TraceEventID)9;
        public const TraceEventID IoPriorityChangeEventID = (TraceEventID)10;
        #endregion

        #region private
        #endregion
    }
}

namespace Microsoft.Diagnostics.Tracing.Parsers.Process
{
    public sealed class ProcessStartTraceData : TraceEvent
    {
        override public int ProcessID { get { return GetInt32At(0); } }
        public DateTime CreateTime { get { return DateTime.FromFileTime(GetInt64At(4)); } }
        public int ParentProcessID { get { return GetInt32At(12); } }
        public int SessionID { get { return GetInt32At(16); } }
        public string ImageName { get { return GetUnicodeStringAt(20); } }

        #region Private
        internal ProcessStartTraceData(Action<ProcessStartTraceData> action, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.Action = action;
        }
        protected override void Dispatch()
        {
            Action(this);
        }
        protected override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUnicodeString(20)));
            Debug.Assert(!(Version > 0 && EventDataLength < SkipUnicodeString(20)));
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ProcessID", "CreateTime", "ParentProcessID", "SessionID", "ImageName" };
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ProcessID;
                case 1:
                    return CreateTime;
                case 2:
                    return ParentProcessID;
                case 3:
                    return SessionID;
                case 4:
                    return ImageName;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ProcessStartTraceData> Action;
        #endregion
    }
    public sealed class ProcessStopTraceData : TraceEvent
    {
        override public int ProcessID { get { return GetInt32At(0); } }
        public DateTime CreateTime { get { return DateTime.FromFileTime(GetInt64At(4)); } }
        public DateTime ExitTime { get { return DateTime.FromFileTime(GetInt64At(12)); } }
        public int ExitCode { get { return GetInt32At(20); } }
        public int TokenElevationType { get { return GetInt32At(24); } }
        public int HandleCount { get { return GetInt32At(28); } }
        public long CommitCharge { get { return GetInt64At(32); } }
        public long CommitPeak { get { return GetInt64At(40); } }
        public string ImageName { get { if (Version >= 1) return GetUTF8StringAt(76); return GetUTF8StringAt(48); } }
        public long CPUCycleCount { get { if (Version >= 1) return GetInt64At(48); return 0; } }
        public int ReadOperationCount { get { if (Version >= 1) return GetInt32At(56); return 0; } }
        public int WriteOperationCount { get { if (Version >= 1) return GetInt32At(60); return 0; } }
        public int ReadTransferKiloBytes { get { if (Version >= 1) return GetInt32At(64); return 0; } }
        public int WriteTransferKiloBytes { get { if (Version >= 1) return GetInt32At(68); return 0; } }
        public int HardFaultCount { get { if (Version >= 1) return GetInt32At(72); return 0; } }

        #region Private
        internal ProcessStopTraceData(Action<ProcessStopTraceData> action, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName)
            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)
        {
            this.Action = action;
        }
        protected override void Dispatch()
        {
            Action(this);
        }
        protected override void Validate()
        {
            Debug.Assert(!(Version == 0 && EventDataLength != SkipUTF8String(48)));
            Debug.Assert(!(Version == 1 && EventDataLength != SkipUTF8String(76)));
            Debug.Assert(!(Version > 1 && EventDataLength < SkipUTF8String(76)));
        }

        public override string[] PayloadNames
        {
            get
            {
                if (payloadNames == null)
                    payloadNames = new string[] { "ProcessID", "CreateTime", "ExitTime", "ExitCode", "TokenElevationType", "HandleCount", "CommitCharge", "CommitPeak", "ImageName", "CPUCycleCount", "ReadOperationCount", "WriteOperationCount", "ReadTransferKiloBytes", "WriteTransferKiloBytes", "HardFaultCount" };
                return payloadNames;
            }
        }

        public override object PayloadValue(int index)
        {
            switch (index)
            {
                case 0:
                    return ProcessID;
                case 1:
                    return CreateTime;
                case 2:
                    return ExitTime;
                case 3:
                    return ExitCode;
                case 4:
                    return TokenElevationType;
                case 5:
                    return HandleCount;
                case 6:
                    return CommitCharge;
                case 7:
                    return CommitPeak;
                case 8:
                    return ImageName;
                case 9:
                    return CPUCycleCount;
                case 10:
                    return ReadOperationCount;
                case 11:
                    return WriteOperationCount;
                case 12:
                    return ReadTransferKiloBytes;
                case 13:
                    return WriteTransferKiloBytes;
                case 14:
                    return HardFaultCount;
                default:
                    Debug.Assert(false, "Bad field index");
                    return null;
            }
        }

        private event Action<ProcessStopTraceData> Action;
        #endregion
    }
}

